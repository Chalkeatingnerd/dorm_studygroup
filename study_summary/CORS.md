## CORS(Cross-Origin-Resource-Sharing)

### CORS 나오기 전

요즘에는 front-end 레이어와 API server 레이어를 따로 구성하는 경우가 많다.

web front-end 사이트 따로, 서버 따로 둔다는 말이다.

이런 경우, web front-end에서 다른 도메인에 위치한 서버에서 요청을 넣어야 하는 경우가 생긴다. 이런 기능은 당연히 지원되야 하는 기능이 아닌가 생각할 수 있지만, 옛날에는 이런 기능이 당연한 것이
아니었다.   

원래는 도메인이 다르면 서로 요청을 주고받을 수 없게 하려는 게 웹 브라우저의 기본 정책이었다.

그러다가 여러 과정을 겪으면서, CORS라는 방식을 통하면 그게 가능하게끔 풀어주게 된 것이다.

```uml-sequence-diagram
Web Browser->server: Request
server->Web Browser: HTMLPage
```

예전에 웹사이트를 만든다고 하면 상당수 위와 같은 구조였다.

유저가 웹사이트 주소창에 주소값을 입력하면 해당 서버로 요청을 보냄<br>
=> 서버에서는 응답을 할 때 HTML 문서를 반환

즉, 하나의 서버에서 비지니스 로직과 HTML 페이지 빌드를 같이 하는 게 일반적이었다.

모든게 당연하게도 같은 도메인에서 일어났다는 말이다. 중간에 웹사이트에서 서버로 js를 이용해 추가 요청을 넣는다고 해도, 마찬가지로 같은 도메인에서 일어나는 일이었다.

그 당시에는 웹 사이트에서 다른 사이트로 요청을 날리는 게, 피싱사이트와 같이 보안상 악의적인 행동을 하는 걸로 여겨졌다.

그렇기 때문에 웹 사이트에서는 같은 도메인이 아니면 요청 자체를 막는 선택을 했던 것.

---

### 크로스 도메인 요청 수요 증가

하지만 웹사이트가 하는 일이 점점 많아지기 시작했다. 단순히 문서를 제공하는 용도가 아니라, 무언가 Application을 만들기 시작한 것이다.

그러한 과도기적인 상황이 되다 보니, 기존 웹 브라우저 보안정책 때문에 불편한 점들이 점점 생기기 시작한다.

단순히 날씨를 제공해주는 API 서버를 생각해보자.

아까 구축했던 웹 사이트 한켠에 날씨 위젯을 추가해보려 한다.

웹 사이트 방문자에게 날씨도 바로 확인할 수 있는 편의 기능을 넣으려는 것이다. 하나의 해결 방법으로는 직접 구축한 웹 서버에 날씨를 가져오는 라우트를 추가하고, 그걸 부르면 날씨 API서버에 다시 요청을 해서 날씨
정보를 받아와서 웹사이트에서 볼 수 있게 해주는 것이다. 괜찮긴 한데, 굳이 웹 서버를 거칠 필요 없이, 바로 웹 사이트에서 날씨 정보 API서버랑 통신을 하면 되지 않나? 라는 생각이 든다.

하지만, 날씨 API 서버랑, 웹사이트랑 도메인이 다르기 때문에 이렇게 할 수밖에 없는 것이다.

---

### JSONP등장 & CORS 탄생 배경

그러다 개발자들이 찾아낸 해결책이 `JSONP`라는 방식을 사용하는 것이다.

```js
const script = document.createElement('script');
script.src = '//some-domain.com/some-route/?cb=dosomething;';

document
    .querySelector('head')
    .appendChild(script);

function dosomething(content) {
    //do something
}

//script tag content
dosomething({ ... content});
```

지금 시점에는 이러한 방법이 있었다 정도만 보고 넘어가면 된다. HTML script태그의 경우에는 다른 도메인의
파일을 불러오는 것이 가능했다. 원래는 `스크립트 불러오라고 사용했던 기능을 리소스를 전달받는 데 우회적으로 사용`했던 것이
바로 이 `JSONP`였다.

일반적인 방식으로 이러한 서버 요청을 날릴 때, '어떤 함수로 받고싶다'를 함수 이름을 넣어서 요청을 하는 것이다. 그럼 서버에서는 그 함수 이름을 넣고, 
매개변수로 보내줄 데이터를 넣어서 그대로 반환을 해주는 것이다.

그리고 웹 사이트에서는 `스크립트 코드가 끝나면 자동으로 콜백 함수가 실행`되게 하는 것이다.

창의적인 방식이긴 했지만, 웹 브라우저 입장에서는 이러한 우회적인 루트로 보안을 무력화하는걸 방치할 수 없었다.

그렇다고 이러한 우회로를 버그로 판단하고 막아버리기에는 너무 많은 수요가 있었다.

그래서 이런 우회로가 아닌 공싟적인 루트를 쓰라는 의미에서 나온 게 CORS다.

---

### CORS 도입

> API SERVER (domain-a.com)
> 
> ⇅ request & Response with proper CORS headers 
> 
> Client (domain-bbq.com) 

사실 일반적으로 CORS 세팅을 직접 하는 일은 거의 없다. `웹 프론트엔드`에서는 그냥 요청 넣을 때 `CORS 옵션`만 넣으면, request 헤더까지 알아서 다 넣어준다.

`서버`에서도 마찬가지다. 서버에서도 `간단한 옵션`을 통해서 CORS를 켜고 끌 수 있게 돼 있다.

보통은 굳이 찾아보지 않으면 세부 스펙은 자세히 알아볼 일이 생기지 않는 게 당연하다. 하지만 직접 구축할 일이 없더라도, 이러한 것이 있다는 것은 알아두자.

CORS의 디테일한 부분도 찾아보면 나오겠지만, 간단히 요약하자면 다음과 같다.

>서로 다른 도메인의 resource 요청을 주고받기 위해서는 웹 프론트엔드 & 서버에서 특정 작업을 해주어야 한다.<br>
`프론트`의 경우, `requestheader`에 `CORS관련 option`을 넣어주는 것이고,<br>
`서버`의 경우, `responseheader`에 해당하는 `프론트의 요청을 허용`한다는 내용을 넣어주는 것이다.

헤더에 뭘 넣어야 할지는 정확히 정해진 내용이 있고, 그대로 따르면 된다.

---

#### CORS 요청 허용 & http통신 과정 

하나 더 좀 더 특별한 점은 http옵션 메소드이다.

> Client -> Server: 1. Option<br>
> Server -> Client: 2. Allowed from Server<br>
> Client -> Server: 3. GET or POST<br>
> Server -> Client: 4. Response

`크로스 도메인을 요청`을 보내는 작업은 사실 서버에 요청을 한번만 보내는 것은 아니다. 

사용할 때 보통 fetch API와 같은 것을 딱 한번만 보내는 것으로 보이지만, 실제로는 `서버로 요청을 두번 보내게 된다`.

먼저 Server에 `Option메소드를 이용해서 이 요청을 허용할 것인지를 물어본다.`

서버가 그 요청을 허용하게 되면, GET 이나 POST 요청 등을 통해 요청을 보내고 결과를 받아오는 것이다.

>따라서 서버에서도 웹 브라우저로부터 크로스 도메인 요청을 받으려면, 동일한 라우터에 대해서 option 메소드 처리를 따로 하도록 작업을 해 주어야 한다.

보통은 서버 라이브러리에서 간단하게 해주기 때문에 개발할 때 직접 신경 쓸 일은 없다.

이러한 기능들을 잘 활용하면, 서버에서는 특정 라우트만 CORS를 허용하도록 하거나, 특정 도메인에서 오는 요청만 허용하도록 할 수도 있다.









