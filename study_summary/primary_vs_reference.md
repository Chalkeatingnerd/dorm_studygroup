## 원시값과 참조값

javascript에서 제공되는 7가지 데이터 타입 원시값에는 `숫자`, `문자열`, `boolean`, `null`, `undefined`, `symbol`은 크게 원시타입과 객체 타입으로 구분할 수 있다.

`null`과 `undefined`를 제외한 모든 것들은 `객체`와 같이 동작한다.

원시값은 변경이 불가능하지만 객체는 변경이 가능한 값이다.

---

### 1원시값

#### 1.1 값의 불변성과 메모리 할당

변수 할당시 변수(확보된 메모리 공간)에는 `실제 값`이 저장된다.

원시값을 갖는 변수를 다른 변수에 할당하면, 원본 원시값이 복사되어 전달되는데, 이것을 `값에 의한 전달(call-by-value)`라고 한다.

한번 생성된 원시값은 변경할 수 없다.

`변수`는 하나의 값을 저장하기 위해 확보한 메모리 공간, 그리고 그 메모리 공간을 식별할 수 있도록 붙인 이름이다.

`값`은 변수에 저장된 데이터로서 표현식이 평가돼 생성된 결과이다.

원시값을 할당한 변수에 새로운 원시값을 재할당하면, 메모리 공간에 저장돼 있는 재할당 이전의 원시값을 변경하는 것이 아니라, 새로운 메모리 공간을 확보하고, 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한
원시값을 가리킨다.

이 때 변수가 참조하던 메모리 공간의 주소가 바뀌게 된다. 값의 이러한 특성을 `불변성`이라고 한다. 불변성을 갖는 원시 값을 할당한 변수는 `재할당` 이외에 변수 값을 변경할 수 있는 방법이 없다.

#### 1.2 문자열과 불변성

원시값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야 한다. 이를 위해 원시 타입별로 공간의 크기는 미리 정해져있다.

단 ECMAScript 사양에 문자열 타입과 숫자 타입 외 원시 타입은 크기를 명확히 규정하고 있지 않아 브라우저에 따라 원시 타입의 크기가 다를 수 있다.

> 문자열 : 1개의 문자는 2바이트의 메모리 공간에 저장<br>
=> 문자열은 몇 개의 문자로 이뤄져있는지에 따라 필요한 메모리 공간의 크기가 결정<br>
> 10개의 문자로 이뤄진 문자열은 20바이트가 필요
>
>숫자 : 1도 1000000도 동일한 8바이트가 필요

```js
var str = 'Hello'; //5x2바이트
str = 'world';

var emptyStr = ''; //0개 문자로 이뤄진 빈 문자열
```

첫 번째 문 실행 => 'Hello'문자열이 생성 => str은 문자열 'Hello'가 저장된 메모리 공간의 첫 번째 메모리 셀 주소 가리킴

두 번째 문 실행 => 'Hello'를 수정하는 것이 아니라 새로운 문자열 'World'생성 => str가 'World'를 가리킴

처음 생성한 'Hello', 'World' 모두 메모리에 존재, str이 가리키는 주소가 바뀐 것

> 유사 배열 객체
> length 프로퍼티를 갖는 객체를 말한다.
>
> 문자열은 length 프로퍼티를 가지는 유사 배열 객체로, 배열처럼 인덱스로 프로퍼티 값이 접근 가능, for문으로 순회 가능

```js
var str = 'string';

console.log(str[0]); //s
console.log(str.length); //6
console.log(str.toUpperCase()); //STRING
var str = 'string'; //str이 'string'이라는 새로운 메모리 공간 가르킴
str[0] = 's';//원시값이므로 변경 불가.
```

#### 1.3 call-by-value

원시값을 갖는 변수를 변수에 할당할 경우, 할당받는 변수의 원시값이 복사돼 전달

```js
var num1 = 80;
var num2 = num1;
console.log(num1); //80
console.log(num2); //80

num1 = 100;

console.log(num1); //100
console.log(num2); //80
```

`변수에 변수를 할당할 때`

`num2 = num1`에서 `num1`은 변수값 `80`으로 평가 => `num2`변수에 `80` 할당 (새롭게 생성된 `80`)

메모리상, 변한 `num1`의 원시값과 `num2`의 원시값은 다른 메모리에 저장된 별개 값이고, 물론 새로 `num1`에 할당된 `100`도 다른 메모리에 저장된 별개 값이다.

```js
var num1 = 80;

var num2 = num1;
console.log(num1, num2); //80 80
console.log(num1 === num2); //true
```

`num1`, `num2`는 숫자 `80`을 갖는다는 점에서 동일하다. 하지만 `num1`, `num2`는 다른 메모리 공간에 저장된 별개의 값이다.

```js
var num1 = 80;
var num2 = num1;

num1 = 100;

console.log(num1 === num2) //false ==> 100, 80
```

엄밀하게 말하면, 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되는 것이고, call-by-value라는 말이 헷갈리게 할 수 있다.
`변수와 같은 식별자는 값이 아닌 메모리 주소를 기억하는 것`이라는것을 잊지말자.

> var num2 = num1은 두가지로 생각할 수 있다.
>
> 새로운 80을 생성해서 메모리 주소를 전달하는 방식 => 이 방식은 할당 시점에 두 변수가 기억하는 메모리상 주소가 다르다.
>
> num1의 변수 값 80의 메모리 주소를 그대로 전달하는 방식 => 이 방식은 두 변수가 기억하는 메모리 주소가 같다.
>
> 이처럼, call-by-value도 사실 값을 전달하는 것이 아니라, 메모리 주소를 전달하는 것이다. 그리고 전달된 메모리 주소를 통해 메모리 공간에 접근해 값을 참조할 수 있다.

### 2. 객체

객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 `참조 값`이 저장된다.

객체를 가리키는 변수를 다른 변수에 할당하면, 원본의 참조 값이 복사돼 전달되는데, 이를 `참조에 의한 전달(call-by-reference)`라고 한다.

#### 2.1 객체 특성

* 객체는 프로퍼티 개수가 정해져 있지 않고, 동적으로 추가/삭제할 수 있다.
* 객체는 프로퍼티 값에도 제약이 없다. 따라서 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.
* 객체는 복합적인 자료구조이므로, 객체를 관리하는 방식이 원시값과 비교해서 복잡하고, 구현 방식도 브라우저에 따라 다를 수 있다.
* 원시값은 상대적으로 적은 메모리를 차지하지만, 객체는 경우에 따라서 크기가 매우 클 수도 있다.<br>
  => 객체를 생성하고 프로퍼티에 접근하는 것도 원시값과 비교할 때 비용이 많이 든다.

> ### javascript의 프로퍼티 속성
> > valuable<br>
> value는 프로퍼티의 속성값<br>
> value는 단지 값을 의미할 뿐 다른 기능은 없음
> `value에 대한 접근 권한자 설정`을 위해 `enumerable`, `writable`, `configurable`를 이용해
>
> > get & set
> get & set은 ES6에서부터 나온 문법으로, 속상값에 대한 `접근 권한자 역할`을 할 수 있다.<br>
> 그렇기 때문에 `get, set, writable 속성을 함께 줄 수 없다`.<br>
> get & set 자체로 writable의 역할을 가지고 있기 때문
>
> > enumerable
> 만약 property가 열거할 수 있는 속성이라면<br>
> `for...in...루프를 사용해서 그것들에 접근할 수 있다.`
> 객체의 열거 가능한 속성의 키는 Object.keys 메서드를 이용해 반환 받을 수 있다.
>
> > writable
>
> > configurable
>

#### 2.2 변경 가능한 값

> 객체 타입의 값, 객체는 변경 가능한 값이다.

```js
var person = {
    name: 'Kim'
};
```

원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시값에 접근할 수 있다. 즉, 원시값을 할당한 변수는 원시값 자체를 값으로 갖는다.
하지만 `객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면, 참조값에 접근`할 수 있다. `참조값`은 `생성된 객체가 저장된 메모리 공간의 주소` 그 자체이다.

```js
//할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성
var person = {
    name: 'Kim'
}

//person 변수에 저장돼 있는 참조 값으로, 실제 객체에 접근
console.log(person) // {name : 'Kim'}
```

일반적으로 원시값을 할당한 변수의 경우, "변수는 OO값을 갖는다", "변수 값은 OO다"와 같이 말한다.<br>
객체를 할당한 변수의 경우, "변수는 객체를 참조하고 있다" 또는 "변수는 객체를 가리키고 있다."라고 표현한다.

위의 예에서 `person`변수는 객체 `{name: 'Kim'}`를 가리키고(참조하고)있다.

원시값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 `객체는 변경이 가능한 값`이다.<br>
따라서 재할당 없이 프로퍼티를 동적으로 추가/갱신/삭제할 수 있다.

```js
var persron = {
    name: 'Kim'
};

//프로퍼티 갱신
person.name = 'Lee';

//프로퍼티 생성
person.addreess = 'Seoul';

console.log(person); // {name: 'Kim', address: 'Seoul'}
```

> 리터럴 : 데이터 그 자체<br>
>
> 인스턴스(클래스의 데이터)는 리터럴이 될 수 있을까? => NO, 인스턴스 내부의 값을 변경하지 않는다면 모를까, 인스턴스는 동적으로 사용하기 위해 작성하기 때문에 리터럴이 될 수 없음.
>
> 변수의 리터럴 : 변수의 값이 변하지 않는 데이터 (메모리 위치의 값)
>
> 객체 리터럴 : 데이터가 변하지 않도록 설계한 클래스를 불변 클래스(immutable class)라고 한다.<br>
> 해당 클래스는 한번 생성하면 객체 안의 데이터가 변하지 않는다. 변할 상황인 경우, 새로운 객체를 만들어준다.<br>
> e.g. String, Color과 같은 클래스...

#### 2.3 참조에 의한 전달 (call-by-reference)

```js
var person = {
    name: 'Kim'
};

//참조 값을 복사
var clone = person;
```

객체를 가리키는 변수를 다른 변수에 할당하면, 원본의 참조 값이 복사돼 전달된다.

원본 `person`을 사본 `clone`에 할당하면, 원본 `person`의 참조값을 복사해 `clone`에 저장한다.<br>
이 때, `person`과 사본`clone`는 메모리 주소는 다르지만, 동일한 참조값을 갖는다.<br>
즉, 두개의 식별자가 하나의 객체를 공유한다는 말이다.<br>
따라서 어느 한쪽이든 프로퍼티를 수정하면, 영향을 주고받는다.

```js
var person = {
    name: 'Kim',
};

var clone = person;

console.log(clone === person); //true

clone.name = 'Lee';
person.address = 'Seoul';

console.log(person); // {name: 'Lee', address: 'Seoul'}
console.log(clone); // {name: 'Lee', address: 'Seoul'}
```

call-by-value와 call-by-reference 식별자가 기억하는 메모리 공간에 저장돼 있는 값을 복사해서 전달한다는 면에서 동일하다. <br>
하지만 식별자가 기억하는 메모리 상의 공간, 즉 변수에 저장된 값이 원시값이냐 참조값이냐는 차이가 난다.


